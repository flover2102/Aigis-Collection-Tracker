<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<!-- ðŸ”´ CORRECTION DES IMAGES ICI -->
<!-- Cette ligne force le navigateur Ã  cacher l'origine du site au Wiki. -->
<!-- Le Wiki acceptera donc d'afficher les images. -->
<meta name="referrer" content="no-referrer" />

<title>Aigis â€” Collection Tracker (Black)</title>
<style>
:root{--accent:#5bff9e;--accent-muted:#2c4837;--bg:#071021;--muted:#9aa6b2;--info-color:#38bdf8;}
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:Inter,system-ui;background:var(--bg);color:#e6f0f6}
.container{max-width:1200px;margin:18px auto;padding:18px}

.hidden{display:none !important}

/* Header layout */
.header{display:flex;align-items:flex-start;gap:16px;flex-wrap:wrap;margin-bottom:12px;}
.title-group { display: flex; flex-direction: column; gap: 12px; margin-right: auto; }
.h1{font-size:20px; line-height: 1.2;}

/* BANNER VIEW MODE */
.shared-banner {
  background: rgba(13, 37, 56, 0.95);
  border: 2px solid var(--info-color);
  box-shadow: 0 0 15px rgba(56, 189, 248, 0.25);
  padding: 10px 16px; 
  border-radius: 12px; 
  display: inline-flex; align-items: center; gap: 20px;
  align-self: flex-start;
  transition: all 0.3s ease;
}
.shared-text-group { display: flex; flex-direction: column; }
.shared-label { font-size: 10px; text-transform: uppercase; letter-spacing: 1px; color: #7dd3fc; opacity: 0.8; margin-bottom: 2px; }
.shared-title { font-size: 16px; font-weight: 900; color: #fff; text-transform: uppercase; letter-spacing: 0.5px; text-shadow: 0 0 10px rgba(56, 189, 248, 0.5); }

.btn-exit {
  background: rgba(56, 189, 248, 0.1); border: 1px solid var(--info-color); color: var(--info-color);
  padding: 6px 14px; font-size: 12px; font-weight: bold; border-radius: 6px; cursor: pointer; transition: all 0.2s; text-transform: uppercase;
}
.btn-exit:hover { background: var(--info-color); color: #071021; box-shadow: 0 0 10px var(--info-color); }

.collection-stats {
  background: rgba(255,255,255,0.05); padding: 8px 12px;
  border-radius: 8px; font-size: 14px; border: 1px solid rgba(255,255,255,0.1);
  align-self: center; 
}
.collection-stats b { color: var(--accent); }

.toolbar-line{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.btn{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,.10);background:var(--accent-muted);color:#e6f0f6;cursor:pointer;transition:all .12s; font-size: 13px;}
.btn:hover{background:rgba(255,255,255,0.15);}
.btn.active{background:var(--accent);color:#071827}

/* Feedback Copied */
.btn.copied { background: #fff; color: #071021; font-weight: bold; transform: scale(1.05); border-color: #fff; }

.input{
  padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.25);
  background:transparent; color:inherit;
}

/* Grid & Cards */
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:12px;margin-top:28px}
.card{padding:8px;border-radius:8px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,.03);text-align:center;cursor:pointer;position:relative;min-height:170px;transition: all 0.1s ease-out;}
.card:hover { background: rgba(255,255,255,0.06); }
.card img{width:96px;height:96px;object-fit:contain;margin-top: 12px;} 
.card .title{font-size:13px;margin-top:8px;display:flex;align-items:center;gap:6px;justify-content:center}
.card .meta{font-size:12px;color:var(--muted)}
.card.owned{outline:3px solid var(--accent);background:var(--accent-muted);}
.read-only .card { cursor: default; }

.check-indicator {
  position: absolute; top: 8px; right: 8px; width: 20px; height: 20px;
  border: 2px solid rgba(255,255,255,0.3); border-radius: 4px; transition: all 0.2s; background: rgba(0,0,0,0.3);
}
.card.owned .check-indicator { background: var(--accent); border-color: var(--accent); }
.card.owned .check-indicator::after {
  content: 'âœ”'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  font-size: 14px; color: #071827; font-weight: bold;
}

.tags{display:flex;flex-wrap:wrap;gap:4px;justify-content:center;margin-top:8px}
.tag{font-size:11px;padding:4px 6px;border-radius:6px;background:rgba(255,255,255,0.02);color:var(--muted);max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.small{font-size:13px;color:var(--muted)}
.loading{margin-top:8px;font-size:13px;opacity:.8}

/* UI des filtres */
.filter-controls {
  border-top: 1px solid rgba(255,255,255,0.05); border-bottom: 1px solid rgba(255,255,255,0.05);
  padding: 12px 0; margin-top: 16px; display: flex; flex-direction: column; gap: 12px; 
}
.filter-group { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; }
.filter-group-label { font-size: 13px; color: var(--muted); margin-right: 8px; min-width: 80px; text-align: right; }

/* Dropdowns */
.dropdown-wrapper { position: relative; display: inline-block; }
.dropdown-panel {
  position:absolute; top:100%; left:0;
  background:#0d1a2f; border:1px solid rgba(255,255,255,.1);
  padding: 8px; border-radius: 8px; display: none; flex-direction: column; gap: 6px;
  z-index: 20; min-width: 180px; margin-top: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.dropdown-panel:not(.hidden) { display: flex; }
.dropdown-panel .btn { background: #071021; text-align: left; }
.dropdown-panel .btn.active { background: var(--accent); color: #071827; font-weight: bold; }

.sort-control { margin-left: 12px; }
.sort-select {
  padding: 8px; border-radius: 8px; background: var(--accent-muted); color: #e6f0f6; border: 1px solid rgba(255,255,255,.10); cursor: pointer; outline: none;
}

</style>
</head>
<body>
<div class="container">
  
  <div class="header">
    <div class="title-group">
      <h1 class="h1">Aigis â€” Collection Tracker (Black)</h1>
      
      <!-- BANNER VIEW MODE -->
      <div id="shared-banner" class="shared-banner hidden">
        <div class="shared-text-group">
          <span class="shared-label">Shared Collection</span>
          <span class="shared-title">VIEW MODE</span>
        </div>
        <button id="btn-exit-share" class="btn-exit">Exit</button>
      </div>
    </div>
    
    <div id="collection-stats" class="collection-stats">
      Collection: 0% (0/0)
    </div>

    <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
      <button id="btn-share-link" class="btn">Share Link</button>
      <button id="btn-export" class="btn">Export</button>
      <button id="btn-import" class="btn">Import</button>
      
      <div class="dropdown-wrapper">
        <button id="btn-options" class="btn">Options â–¾</button>
        <div id="options-panel" class="dropdown-panel hidden" style="right:0;left:auto;min-width:180px;">
          <button id="btn-toggle-tags" class="btn">Show Tags</button>
          <button id="btn-toggle-fodder" class="btn">Show Fodder</button>
        </div>
      </div>
      
      <input id="file-input" type="file" accept="application/json" class="hidden" />
    </div>
  </div>

  <div class="toolbar-line" style="justify-content:center;margin-top:14px;align-items:center;">
    <input id="search" class="input" placeholder="Search..." style="min-width:420px;max-width:70%" />
    
    <select id="sort-select" class="sort-select">
      <option value="name">Sort: Name (A-Z)</option>
      <option value="release">Sort: Release (Newest)</option>
    </select>

    <div id="search-stats" class="small" style="margin-left:12px">0 shown</div>
  </div>

  <div id="filter-controls" class="filter-controls"></div>
  
  <div id="loading" class="loading">Loading data...</div>
  <div id="grid" class="grid" aria-live="polite"></div>
</div>

<script>
const API='https://aigis.fandom.com/api.php';
const LOCAL_OWNED_KEY='aigis-owned-v6';
const LOCAL_DATA_KEY='aigis-units-cache-v7'; 

let units=[];
let owned=new Set();
let isSharedMode = false;
let showMode='all'; 
let currentSort = 'name';

// --- COMPRESSION ULTRA-OPTIMISEE (Bitmap V2) ---
async function compressData(ownedSet) {
  const refUnits = [...units].sort((a,b) => a.numericId - b.numericId);
  const numBytes = Math.ceil(refUnits.length / 8);
  const buffer = new Uint8Array(numBytes);
  
  refUnits.forEach((u, index) => {
    if (ownedSet.has(u.id)) {
      const byteIndex = Math.floor(index / 8);
      const bitIndex = index % 8;
      buffer[byteIndex] |= (1 << bitIndex);
    }
  });

  const stream = new Blob([buffer]).stream();
  const compressed = stream.pipeThrough(new CompressionStream("gzip"));
  const response = await new Response(compressed);
  const blob = await response.blob();
  const resultBuffer = await blob.arrayBuffer();
  
  let base64 = btoa(String.fromCharCode(...new Uint8Array(resultBuffer)));
  return 'v2-' + base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

async function decompressData(encodedString) {
  let base64 = encodedString.startsWith('v2-') ? encodedString.substring(3) : encodedString;
  let str = base64.replace(/-/g, '+').replace(/_/g, '/');
  while (str.length % 4) str += '=';
  
  const binary = atob(str);
  const bytes = Uint8Array.from(binary, c => c.charCodeAt(0));
  const stream = new Blob([bytes]).stream();
  const decompressed = stream.pipeThrough(new DecompressionStream("gzip"));
  const response = await new Response(decompressed);
  const buffer = await response.arrayBuffer();
  const bitmap = new Uint8Array(buffer);
  
  const result = new Set();
  const refUnits = [...units].sort((a,b) => a.numericId - b.numericId);
  
  refUnits.forEach((u, index) => {
    const byteIndex = Math.floor(index / 8);
    const bitIndex = index % 8;
    if (byteIndex < bitmap.length && (bitmap[byteIndex] & (1 << bitIndex))) {
      result.add(u.id);
    }
  });
  return result;
}

// 1. Initialisation
async function init() {
  const cachedData = localStorage.getItem(LOCAL_DATA_KEY);
  let hasCache = false;
  if (cachedData) {
    try {
      const cache = JSON.parse(cachedData);
      if (Date.now() - cache.timestamp < 86400000 && Array.isArray(cache.units) && cache.units.length > 0) {
        units = cache.units;
        hasCache = true;
        render();
        el.loading.classList.add('hidden');
      }
    } catch(e) { console.warn("Invalid Cache"); }
  }
  
  if (!hasCache) { await fetchDataFromWiki(); }
  
  await handleUrlMode();
  
  if (el.search) el.search.addEventListener('input', () => render());
  renderStaticFilters();
}

async function handleUrlMode() {
  const urlParams = new URLSearchParams(window.location.search);
  
  if (urlParams.has('share')) {
    try {
      const shareCode = urlParams.get('share');
      if (shareCode.startsWith('v2-')) {
        owned = await decompressData(shareCode);
        activateSharedMode();
      } else {
        alert("Old link format not supported.");
        loadLocal();
      }
    } catch (e) { console.error("Link error", e); loadLocal(); }
  } else if (urlParams.has('data')) {
    try { owned = new Set(JSON.parse(atob(urlParams.get('data')))); activateSharedMode(); }
    catch(e) { loadLocal(); }
  } else {
    loadLocal();
  }
  render();
  updateStats();
}

function loadLocal() {
  owned = new Set(JSON.parse(localStorage.getItem(LOCAL_OWNED_KEY)||'[]'));
}

function activateSharedMode() {
  isSharedMode = true;
  showMode = 'owned';
  document.getElementById('shared-banner').classList.remove('hidden');
  document.body.classList.add('read-only');
  // Auto-active le bouton "Owned"
  document.querySelectorAll('.filter-controls button').forEach(b => {
    if(b.textContent === 'Owned') b.classList.add('active');
    if(b.textContent === 'Unowned') b.classList.remove('active');
  });
}

document.getElementById('btn-exit-share').addEventListener('click', () => {
  window.location.href = window.location.pathname; 
});

// --- Filtres ---
let activeRanges=new Set();
let activeRoles=new Set();
let activeGenders=new Set();
let activeKingdoms=new Set();
let activeRaces=new Set();
let activeArchetypes=new Set();
let activeSeasonal=new Set();
let activeCrossover=new Set();

// --- UI ---
let showTags = false; 
let showFodder = false;
let openDropdownPanel = null;

const LIST_RACES=["Angels Race","Beastfolk","Birdfolk","Celestials","Dark Elves","Demons","Dragonfolk","Dwarves","Elves","Giants","Goblins","Gods","Half-Demons","Half-Elves","Half-Gods","Hermits Race","Humans","Machines","Merfolk","Nendoroids","Orcs","Spirits","Undead","Vampires","Youkai"];
const UI_RACES = [...LIST_RACES, "Other"];
const FIXED_KINGDOMS=["Deep Sea Units","Desert Country","Eastern Country","Flower Country","Kingdom","Makai Units","White Empire"];
const FIXED_ARCHETYPES=["Artillery","Bowmen","Cavalry","Clergy","Dragons","Flying","Gunners","Heavy","Magicians","Nobles"];
const FIXED_SEASONAL=["New Year's Units","Valentine's Day Units","Hot Springs Units","Easter Hunts","School Units","June Bride Units","Summer Units","Halloween Units","Christmas Units"];
const FIXED_CROSSOVER=["Koihime Units","Kingdom of Pars","Seven Deadly Sins"];
const FIXED_RANGES = ["Melee", "Ranged", "Omni"];
const FIXED_ROLES = ["Hero Units", "Player Units"];
const FIXED_GENDERS = ["Male Units", "Female Units"];

const el={
  search:document.getElementById('search'),
  grid:document.getElementById('grid'),
  stats:document.getElementById('search-stats'),
  colStats:document.getElementById('collection-stats'),
  loading:document.getElementById('loading'),
  filterControls: document.getElementById('filter-controls'),
  sortSelect: document.getElementById('sort-select')
};

// --- Helpers ---
function saveOwned(){
  if (isSharedMode) return;
  localStorage.setItem(LOCAL_OWNED_KEY,JSON.stringify([...owned]));
}

function saveUnitsToCache(data) {
  try { localStorage.setItem(LOCAL_DATA_KEY, JSON.stringify({ timestamp: Date.now(), units: data })); } 
  catch(e) {}
}

function updateStats(){
  if(!units.length) return;
  const collectionnableUnits = units.filter(u => (!showFodder && u.isFodder) ? false : true);
  const totalCol = collectionnableUnits.length;
  const ownedCol = collectionnableUnits.filter(u => owned.has(u.id)).length;
  const percent = totalCol > 0 ? ((ownedCol / totalCol) * 100).toFixed(1) : 0;
  
  el.colStats.innerHTML = `Collection: <b>${percent}%</b> <span style="opacity:0.7">(${ownedCol}/${totalCol})</span>`;
  const shown = units.filter(u=>matchesFilters(u)).length;
  el.stats.textContent = `${shown} shown`;
}

function normalize(s){return String(s||'').replace(/^Category:/i,'').replace(/_/g,' ').trim();}
function nk(s){return String(s||'').toLowerCase().trim();}
function buildApiTags(catList){return (catList||[]).map(c=>normalize(c.title||c));}

function determineRange(tags){
  const t = (tags||[]).map(x => nk(x));
  if(t.some(x => x.includes('omni'))) return 'Omni';
  if(t.some(x => x.includes('rearguard'))) return 'Ranged';
  if(t.some(x => x.includes('vanguard'))) return 'Melee';
  return 'Melee';
}

function processUnitData(rawData) {
    const apiTags = rawData.apiTags || buildApiTags(rawData.categories||[]);
    let races = apiTags.filter(t => LIST_RACES.includes(t));
    if (races.length === 0) races = ["Other"];
    const pid = parseInt(rawData.pageid || rawData.id, 10) || 0;
    
    return {
      id: String(pid),
      numericId: pid,
      title: normalize(rawData.title || rawData.pageTitle || rawData.name),
      img: rawData.img || rawData.image || '',
      apiTags: apiTags,
      tags: rawData.tags || [],
      range: rawData.range || determineRange(apiTags),
      genders: apiTags.filter(t => FIXED_GENDERS.includes(t)),
      roles: apiTags.filter(t => FIXED_ROLES.includes(t)),
      kingdoms: apiTags.filter(t => FIXED_KINGDOMS.includes(t)),
      races: races,
      archetypes: apiTags.filter(t => FIXED_ARCHETYPES.includes(t)),
      seasonal: apiTags.filter(t => FIXED_SEASONAL.includes(t)),
      crossover: apiTags.filter(t => FIXED_CROSSOVER.includes(t)),
      isFodder: apiTags.some(t => nk(t) === 'fodder units')
    };
}

// --- Filtrage ---
function matchesFilters(u){
  if (!showFodder && u.isFodder) return false;
  const q=nk(el.search.value||'');
  if(q && !nk(u.title).includes(q)) return false;
  if(showMode==='owned' && !owned.has(u.id)) return false;
  if(showMode==='notowned' && owned.has(u.id)) return false;
  
  if(activeRanges.size && !activeRanges.has(u.range)) return false; 
  if(activeRoles.size && !u.roles.some(r => activeRoles.has(r))) return false;
  if(activeGenders.size && !u.genders.some(g => activeGenders.has(g))) return false;
  if(activeKingdoms.size && !u.kingdoms.some(k => activeKingdoms.has(k))) return false;
  if(activeRaces.size) {
    const hasDefinedRace = u.races.some(r => activeRaces.has(r));
    const isOtherAndActive = activeRaces.has("Other") && u.races.includes("Other");
    if (!hasDefinedRace && !isOtherAndActive) return false;
  }
  if(activeArchetypes.size && !tagSetMatches(u, activeArchetypes)) return false;
  if(activeSeasonal.size && !tagSetMatches(u, activeSeasonal)) return false;
  if(activeCrossover.size && !tagSetMatches(u, activeCrossover)) return false;
  return true
}

function tagSetMatches(u, selectedSet) {
  if (selectedSet.size === 0) return true;
  const apiNk = (u.apiTags || []).map(nk);
  for (const s of selectedSet) { if (apiNk.includes(nk(s))) return true; }
  return false;
}

// --- Rendu ---
function render(){
  el.grid.innerHTML='';
  if(!units || units.length === 0) {
     el.grid.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:20px;">No units found (or loading). Try refreshing.</div>';
     return;
  }
  const frag=document.createDocumentFragment();
  
  const sortedUnits = [...units].sort((a,b) => {
    if (currentSort === 'release') return b.numericId - a.numericId;
    else return a.title.localeCompare(b.title);
  });
  
  for(const u of sortedUnits){
    if(!u.id || !matchesFilters(u)) continue;
    
    const card=document.createElement('div');
    card.className='card';
    if(owned.has(u.id)) card.classList.add('owned');
    
    const checkbox = document.createElement('div');
    checkbox.className = 'check-indicator';
    card.appendChild(checkbox);

    const img=document.createElement('img');
    img.src=u.img||'';
    img.alt=u.title;
    img.loading = "lazy"; 
    
    const title=document.createElement('div');
    title.className='title';
    const nameSpan=document.createElement('span');
    nameSpan.textContent=u.title;
    
    const wikiA=document.createElement('a');
    wikiA.href=`https://aigis.fandom.com/wiki/${encodeURIComponent(u.title.replace(/ /g,'_'))}`;
    wikiA.target='_blank';
    wikiA.className='icon-link';
    wikiA.textContent='ðŸ”—';
    wikiA.addEventListener('click', (e) => e.stopPropagation());

    title.appendChild(nameSpan);
    title.appendChild(wikiA);
    
    const meta=document.createElement('div');
    meta.className='meta';
    meta.textContent=u.range||'';
    
    card.appendChild(img);
    card.appendChild(title);
    card.appendChild(meta);
    
    if(showTags){
      const tagsWrap=document.createElement('div');
      tagsWrap.className='tags';
      const uniq=new Set((u.apiTags||[]).map(t=>t));
      Array.from(uniq).slice(0,20).forEach(t=>{
        const tk=document.createElement('span');
        tk.className='tag';
        tk.textContent=t;
        tagsWrap.appendChild(tk);
      });
      card.appendChild(tagsWrap);
    }
    
    card.addEventListener('click',()=>{
      if(isSharedMode) return; 
      if(owned.has(u.id)) owned.delete(u.id);
      else owned.add(u.id);
      saveOwned();
      card.classList.toggle('owned', owned.has(u.id));
      updateStats(); 
    });
    frag.appendChild(card);
  }
  el.grid.appendChild(frag);
  updateStats();
}

el.sortSelect.addEventListener('change', (e) => {
  currentSort = e.target.value;
  render();
});

// --- Share Link Click ---
document.getElementById('btn-share-link').addEventListener('click', async (e) => {
  if (owned.size === 0) return alert("Nothing to share!");
  
  const btn = e.target;
  const originalText = btn.textContent;
  
  try {
    const encoded = await compressData(owned);
    const url = `${window.location.href.split('?')[0]}?share=${encoded}`;
    
    await navigator.clipboard.writeText(url);
    
    btn.textContent = "Copied!";
    btn.classList.add('copied');
    setTimeout(() => {
      btn.textContent = originalText;
      btn.classList.remove('copied');
    }, 2000);
    
  } catch (err) {
    console.error(err);
    alert("Error creating link");
  }
});

// --- Filtres UI ---
function createButtonGroup(label, optionsList, activeSet) {
  const group = document.createElement('div');
  group.className = 'filter-group';
  const labelEl = document.createElement('div');
  labelEl.className = 'filter-group-label';
  labelEl.textContent = label + ' :';
  group.appendChild(labelEl);
  optionsList.forEach(option => {
    const key = option; 
    const b = document.createElement('button');
    b.className = 'btn';
    b.textContent = option;
    b.dataset.key = key;
    b.classList.toggle('active', activeSet.has(key));
    b.addEventListener('click', e => {
      e.stopPropagation(); 
      if (activeSet.has(key)) activeSet.delete(key);
      else activeSet.add(key);
      b.classList.toggle('active', activeSet.has(key));
      render();
    });
    group.appendChild(b);
  });
  return group;
}

function createDropdown(label, optionsList, activeSet) {
  const wrapper = document.createElement('div');
  wrapper.className = 'dropdown-wrapper';
  const btn = document.createElement('button');
  btn.className = 'btn';
  btn.textContent = label + ' â–¾';
  const panel = document.createElement('div');
  panel.className = 'dropdown-panel hidden';
  optionsList.forEach(option => {
    const key = option;
    const b = document.createElement('button');
    b.className = 'btn';
    b.textContent = option;
    b.dataset.key = key;
    b.classList.toggle('active', activeSet.has(key));
    b.addEventListener('click', e => {
      if (activeSet.has(key)) activeSet.delete(key);
      else activeSet.add(key);
      b.classList.toggle('active', activeSet.has(key));
      render();
    });
    panel.appendChild(b);
  });
  btn.addEventListener('click', e => {
    e.stopPropagation();
    const isHidden = panel.classList.contains('hidden');
    if (openDropdownPanel && openDropdownPanel.panel !== panel) closeOpenDropdown();
    const optionsPanel = document.getElementById('options-panel');
    if (optionsPanel && !optionsPanel.classList.contains('hidden')) {
      optionsPanel.classList.add('hidden');
      document.getElementById('btn-options').classList.remove('active');
    }
    panel.classList.toggle('hidden', !isHidden);
    btn.classList.toggle('active', isHidden);
    openDropdownPanel = isHidden ? { btn, panel, wrapper } : null;
  });
  wrapper.appendChild(btn);
  wrapper.appendChild(panel);
  return wrapper;
}

function renderStaticFilters() {
  el.filterControls.innerHTML = ''; 
  const statusGroup = document.createElement('div');
  statusGroup.className = 'filter-group';
  const statusLabel = document.createElement('div');
  statusLabel.className = 'filter-group-label';
  statusLabel.textContent = 'Status :';
  statusGroup.appendChild(statusLabel);
  
  const ownedBtn = document.createElement('button');
  ownedBtn.className = 'btn';
  ownedBtn.textContent = 'Owned';
  if (showMode === 'owned') ownedBtn.classList.add('active');
  
  ownedBtn.addEventListener('click', () => {
    if (showMode === 'owned') { showMode = 'all'; ownedBtn.classList.remove('active'); }
    else { showMode = 'owned'; ownedBtn.classList.add('active'); notOwnedBtn.classList.remove('active'); }
    render();
  });
  
  const notOwnedBtn = document.createElement('button');
  notOwnedBtn.className = 'btn';
  notOwnedBtn.textContent = 'Unowned';
  if (showMode === 'notowned') notOwnedBtn.classList.add('active');
  
  notOwnedBtn.addEventListener('click', () => {
    if (showMode === 'notowned') { showMode = 'all'; notOwnedBtn.classList.remove('active'); }
    else { showMode = 'notowned'; notOwnedBtn.classList.add('active'); ownedBtn.classList.remove('active'); }
    render();
  });
  
  statusGroup.appendChild(ownedBtn);
  statusGroup.appendChild(notOwnedBtn);
  el.filterControls.appendChild(statusGroup);
  
  el.filterControls.appendChild(createButtonGroup("Type", FIXED_RANGES, activeRanges));
  el.filterControls.appendChild(createButtonGroup("Role", FIXED_ROLES, activeRoles));
  el.filterControls.appendChild(createButtonGroup("Gender", FIXED_GENDERS, activeGenders));
  el.filterControls.appendChild(createButtonGroup("Kingdom", FIXED_KINGDOMS, activeKingdoms));
  el.filterControls.appendChild(createButtonGroup("Race", UI_RACES, activeRaces));
  el.filterControls.appendChild(createButtonGroup("Archetype", FIXED_ARCHETYPES, activeArchetypes));
  
  const dropdownGroup = document.createElement('div');
  dropdownGroup.className = 'filter-group';
  dropdownGroup.appendChild(createDropdown("Seasonal", FIXED_SEASONAL, activeSeasonal));
  dropdownGroup.appendChild(createDropdown("Crossover", FIXED_CROSSOVER, activeCrossover));
  el.filterControls.appendChild(dropdownGroup);
}

document.addEventListener('click', (e) => {
  const optionsPanel = document.getElementById('options-panel');
  if (optionsPanel && !optionsPanel.classList.contains('hidden') && !optionsPanel.parentElement.contains(e.target)) {
    optionsPanel.classList.add('hidden');
    document.getElementById('btn-options').classList.remove('active');
    if (openDropdownPanel && openDropdownPanel.panel === optionsPanel) openDropdownPanel = null;
  }
  if (openDropdownPanel && !openDropdownPanel.wrapper.contains(e.target)) closeOpenDropdown();
});

function closeOpenDropdown() {
  if (openDropdownPanel) {
    openDropdownPanel.panel.classList.add('hidden');
    openDropdownPanel.btn.classList.remove('active');
    openDropdownPanel = null;
  }
}

// --- Import / Export ---
function exportData(){
  const data={owned:[...owned],units};
  const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download='aigis-collection.json';
  a.click();
}
document.getElementById('btn-export').addEventListener('click',exportData);
document.getElementById('btn-import').addEventListener('click',()=>document.getElementById('file-input').click());

document.getElementById('file-input').addEventListener('change',async e=>{
  const f=e.target.files[0];if(!f) return;
  try{
    const txt=await f.text();
    const parsed=JSON.parse(txt);
    if(parsed.owned) owned=new Set(parsed.owned);
    if(parsed.units && Array.isArray(parsed.units)) {
      units=parsed.units.map(processUnitData);
      saveUnitsToCache(units);
    }
    if(!isSharedMode) saveOwned();
    render(); 
  }catch(err){alert('Invalid JSON file');}
});

// --- Options Dropdown ---
const optionsBtn = document.getElementById('btn-options');
const optionsPanel = document.getElementById('options-panel');
const toggleTagsBtn = document.getElementById('btn-toggle-tags');
const toggleFodderBtn = document.getElementById('btn-toggle-fodder');

if (optionsBtn) {
  const optionsWrapper = optionsBtn.parentElement;
  optionsBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    const isHidden = optionsPanel.classList.contains('hidden');
    if (openDropdownPanel && openDropdownPanel.panel !== optionsPanel) closeOpenDropdown();
    optionsPanel.classList.toggle('hidden', !isHidden);
    optionsBtn.classList.toggle('active', isHidden);
    openDropdownPanel = isHidden ? { btn: optionsBtn, panel: optionsPanel, wrapper: optionsWrapper, id: 'optionsPanel' } : null;
  });
  toggleTagsBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    showTags = !showTags;
    toggleTagsBtn.classList.toggle('active', showTags);
    render();
  });
  toggleFodderBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    showFodder = !showFodder;
    toggleFodderBtn.classList.toggle('active', showFodder);
    render();
  });
}

// --- API Logic ---
async function safeFetch(url,opts={},timeout=15000){const ctl=new AbortController();const id=setTimeout(()=>ctl.abort(),timeout);try{return await fetch(url,{...opts,signal:ctl.signal});}finally{clearTimeout(id);}}

async function fetchAllCategoryMembers(){
  const all=[];let cmcontinue=null;
  do{
    const url=`${API}?action=query&list=categorymembers&cmtitle=Category:Rarity:Black&cmlimit=500&format=json&origin=*`+(cmcontinue?`&cmcontinue=${encodeURIComponent(cmcontinue)}`:'');
    const res=await safeFetch(url);
    if(!res.ok) throw new Error('network');
    const data=await res.json();
    all.push(...(data.query&&data.query.categorymembers?data.query.categorymembers:[]));
    cmcontinue=data.continue&&data.continue.cmcontinue?data.continue.cmcontinue:null;
  }while(cmcontinue);
  return all
}

async function fetchDetails(pageids){
  if(!pageids.length) return {};
  const out={};const chunk=50;
  for(let i=0;i<pageids.length;i+=chunk){
    const slice=pageids.slice(i,i+chunk).join('|');
    const url=`${API}?action=query&pageids=${slice}&prop=pageimages|categories|extracts&piprop=original&exintro=1&explaintext=1&cllimit=500&format=json&formatversion=2&origin=*`;
    try{
      const res=await safeFetch(url);
      if(!res.ok) continue;
      const data=await res.json();
      if(data.query&&data.query.pages){
        data.query.pages.forEach(p=>{
          out[p.pageid]=out[p.pageid]||{title:p.title,image:null,categories:[]};
          if(p.original&&p.original.source) out[p.pageid].image=p.original.source;
          out[p.pageid].categories=(p.categories||[]).map(c=>normalize(c.title||c));
        });
      }
    }catch(e){console.warn('chunk failed',e);}
  }
  return out;
}

async function fetchDataFromWiki() {
  el.loading.textContent = 'Downloading Wiki Data... (This may take a moment)';
  el.loading.classList.remove('hidden');
  try {
    const members = await fetchAllCategoryMembers();
    const pageids = members.map(m=>m.pageid);
    const details = await fetchDetails(pageids);
    units = members.map(m => {
      const d = details[m.pageid]||{title:m.title,image:'',categories:[]};
      return processUnitData({
        pageid: m.pageid,
        title: d.title || m.title,
        image: d.image,
        categories: d.categories
      });
    });
    saveUnitsToCache(units);
    render();
    el.loading.classList.add('hidden');
  } catch(e) {
    console.error(e);
    el.loading.textContent = 'API Error (Check console or try refresh)';
  }
}

// Lance init
init();
</script>
</body>
</html>
